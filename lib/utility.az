struct pair!(A, B)
{
    first: A;
    second: B;
}

fn safe_minus(lhs: u64, rhs: u64) -> u64
{
    assert lhs >= rhs;
    return lhs - rhs;
}

fn hash!(T)(value: T&) -> u64
{
    if @is_fundamental(T) { return value@ as u64; }
    else                  { return value.hash(); }
}

fn swap!(T)(lhs: T&, rhs: T&)
{
    let temp := lhs@;
    lhs@ = rhs@;
    rhs@ = temp;
}

fn qs_partition!(T)(arr: T[], low: u64, high: u64) -> u64
{
    let p := arr[low];
    var i := low;
    var j := high;

    while i < j {
        while arr[i] <= p && i <= high - 1u {
            i = i + 1u;
        }
        while arr[j] > p && j >= low + 1u {
            j = j - 1u;
        }
        if (i < j) {
            swap!(T)(arr[i]&, arr[j]&);
        }
    }

    swap!(T)(arr[low]&, arr[j]&);
    return j;
}

fn partial_sort!(T)(arr: T[], low: u64, high: u64)
{
    if (low >= high) return;
    let pi := qs_partition!(T)(arr, low, high);
    if (pi > 0u) {
        partial_sort!(T)(arr, low, pi - 1u);
    }
    if (pi < @len(arr) - 1u) {
        partial_sort!(T)(arr, pi + 1u, high);
    }
}

fn sort!(T)(arr: T[])
{
    partial_sort!(T)(arr, 0u, @len(arr) - 1u);
}

fn abs(x: i64) -> i64
{
    return x >= 0 ? x : -x;
}

struct zip_pair!(T, U)
{
    left:  T&;
    right: U&;
    index: u64;
}

struct zip_view!(T, U)
{
    _left:  T[];
    _right: U[];
    _curr:  u64;

    fn size(self: const&) -> u64
    {
        return @len(self._left) < @len(self._right) ? @len(self._left) : @len(self._right);
    }

    fn valid(self: const&) -> bool
    {
        return self._curr < self.size();
    }

    fn current(self: const&) -> zip_pair!(T, U)
    {
        return zip_pair!(T, U)(self._left[self._curr]&, self._right[self._curr]&, self._curr);
    }

    fn advance(self: &) -> zip_pair!(T, U)
    {
        let curr := self.current();
        self._curr = self._curr + 1u;
        return curr;
    }
}

fn zip!(T, U)(left: T[], right: U[]) -> zip_view!(T, U)
{
    assert @len(left) == @len(right);
    return zip_view!(T, U)(left, right, 0u);
}