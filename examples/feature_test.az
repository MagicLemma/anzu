# tests all language features, here is a comment

# declaring variables from literals
a := 1               # ints
b := true            # bools
c := "hello world\n" # string literal
d := [1, 2, 3]       # list

# variables from variables
e := a

# while-statements
idx := 0
while idx < 10 {
    print(idx)
    print(", ")
    idx = idx + 1
}
println("")

# if-statements
# basic if
if true {
    print("in true block\n")
}

# if with else
if 2 < 1 {
    # never entered
} else {
    println("in else block")
}

# if with elif
if 1 > 3 {
    # not entered
} else if 2 == 1 + 1 {  # also testing an expression
    println("i just evaluated 2 == 1 + 1")
}

# if with elif and else
if false {
    # nah
} else if false {
    # also nah
} else {
    println("in else after skipping the if and elif")
}

# simple expressions
println(2 + 2)
println(8 * (1 + 6) || 5)
println(true && true)
println(true && false)
println(true || false)

# functions
fn adder(a: int, b: int, c: int) -> int
{
    return a + b + c
}

print("Does adder(1, 2, 3) == 6? ")
if adder(1, 2, 3) == 6 {
    println("yes")
} else {
    println("no")
}

# printing null and showing functions with no return value return null
x := null
y := println(x)
println(y)

# Nested functions
fn outer(a: int, b: int) -> int
{   
    fn nested(c: int) -> int
    {
        return c
    }

    return nested(a + b)
}
println(outer(1, 2))

# For loops
println("list test, 3 elements with a break after the second, should only see two")
println("additionally, there is a while loop with its own break statement which should be fine")
for x in [1, 2, 3] {
    println(x)
    if to_int(x) == 2 {
        while true {
            break # To make sure that this break is not affected by the for
        }
        break
    }
}

new_list := [[1, 2, 3, 4]]
for l in new_list {
    list_push(l, 5)
}
println("new_list should have 5 elements:")
println(new_list)

# Allowing functions from other functions
fn add2(x: int, y: int) -> int
{
    return x + y
}

fn add3(x: int, y: int, z: int) -> int
{
    return add2(x, add2(y, z))
}

println(add3(1, 2, 3))

# Nested Function Lookup
# We define a function, then define a function with the same name within a different
# function. This should not overwrite the original function in the top scope
fn get_num() -> int
{
    return 1
}

fn foo() -> null
{
    fn get_num() -> int
    {
        return 2
    }
}

println(
    "We should get 1 when calling get_num since the version returning 2 is not in this scope"
)
print("get_num() == ")
print(get_num())
print("\n")

fn print_one_to_ten() -> null
{
    for i in range(10) {
        println(i)
    }
}