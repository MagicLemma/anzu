# tests all language features, here is a comment

# declaring variables from literals
a := 1               # ints
b := true            # bools
c := "hello world\n" # string literal
d := [1, 2, 3]       # list

# variables from variables
e := a

# while-statements
idx := 0
while idx < 10 {
    print(idx)
    print(", ")
    idx = idx + 1
}
println("")

# if-statements
# basic if
if true {
    print("in true block\n")
}

# if with else
if 2 < 1 {
    # never entered
} else {
    println("in else block")
}

# if with elif
if 1 > 3 {
    # not entered
} else if 2 == 1 + 1 {  # also testing an expression
    println("i just evaluated 2 == 1 + 1")
}

# if with elif and else
if false {
    # nah
} else if false {
    # also nah
} else {
    println("in else after skipping the if and elif")
}

# simple expressions
println(2 + 2)
println(8 * (1 + 6) > 5)
println(true && true)
println(true && false)
println(true || false)

# functions
fn adder(a: int, b: int, c: int) -> int
{
    return a + b + c
}

print("Does adder(1, 2, 3) == 6? ")
if adder(1, 2, 3) == 6 {
    println("yes")
} else {
    println("no")
}

# printing null and showing functions with no return value return null
x := null
y := println(x)
println(y)

# Allowing functions from other functions
fn add2(x: int, y: int) -> int
{
    return x + y
}

fn add3(x: int, y: int, z: int) -> int
{
    return add2(x, add2(y, z))
}

println(add3(1, 2, 3))

fn print_one_to_ten() -> null
{
    i := 0
    while i < 10 {
        println(i)
        i = i + 1
    }
}

# Struct definition
struct vec2
{
    x: int
    y: int
}

# Attribute access
my_vec := vec2(1, 2)
println(my_vec)
println(my_vec.x)
println(my_vec.y)
my_vec.x = 5
println(my_vec.x)

# Pointers
p_value := 5
p := &p_value

fn hack() -> null {} # Needed otherwise the parser tries to parse "&p_value * ptr". Need semi-colons

*p = 6
println("p_value should now equal 6:")
println(p_value)

# Lists
xl := [1, 2, 3, 4]
xl[2u] = 0
println("Should see [1, 2, 0, 4]:")
println(xl)
println("Size of list is 4:")
println(size_of(xl))

xl2 := [vec2(1, 2), vec2(3, 4)]
println("xl2 should have size 4 but length 2:")
print("size: ")
println(size_of(xl2))
print("length: ")
println(size_of(xl2) / size_of(xl2[0]))

# Pointer Arithmetic
struct span
{
    p: &vec2
    size: uint
}

fn test_ptr_arithmetic(s: span) -> null
{
    idx := 0u
    while idx != s.size {
        println(*(s.p + idx))
        idx = idx + 1u
    }
    *(s.p + 1u) = vec2(10, 20)
}

list_of_vec2s := [vec2(1, 2), vec2(3, 4), vec2(5, 6)]
my_span := span(&list_of_vec2s[0u], 3u)

test_ptr_arithmetic(my_span)
println(list_of_vec2s)

# Member functions
fn square(x: float) -> float
{
    return x * x
}

struct vec3
{
    x: float
    y: float
    z: float

    fn length(self: &vec3) -> float
    {
        x_squared := square(self->x)
        y_squared := square(self->y)
        z_squared := square(self->z)
        return sqrt(x_squared + y_squared + z_squared)
    }
}

v := vec3(3.0, 4.0, 5.0)
println("length of vec3(3.0, 4.0, 5.0):")
println(v.length())